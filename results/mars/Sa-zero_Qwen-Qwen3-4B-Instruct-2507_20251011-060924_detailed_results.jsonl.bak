{"idx": 360829, "project": "linux", "commit_id": "47abea041f897d64dbd5777f0cf7745148f85d75", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/47abea041f897d64dbd5777f0cf7745148f85d75", "commit_message": "io_uring: fix off-by-one in sync cancelation file check\n\nThe passed in index should be validated against the number of registered\nfiles we have, it needs to be smaller than the index value to avoid going\none beyond the end.\n\nFixes: 78a861b94959 (\"io_uring: add sync cancelation API through io_uring_register()\")\nReported-by: Luo Likang <luolikang@nsfocus.com>\nSigned-off-by: Jens Axboe <axboe@kernel.dk>", "ground_truth": 0, "cwe": ["CWE-193"], "cve": "CVE-2022-3103", "cve_desc": "off-by-one in io_uring module.", "vuln": 0, "reasoning": "Step 1: Analyze the code carefully  \nThe function `__io_sync_cancel` is part of the io_uring kernel subsystem and is responsible for canceling asynchronous I/O operations. It takes parameters `tctx`, `cd`, and `fd`, and performs validation and mapping of the file descriptor (`fd`) to a file pointer (`file_ptr`) using a fixed file slot table (`file_table`).\n\nKey operations:\n- Checks if `fd` is within the valid range of user files (`ctx->nr_user_files`).\n- Uses `array_index_nospec(fd, ctx->nr_user_files)` to safely index into the array \u2014 this is a known safe function in kernel code that prevents out-of-bounds access via speculative execution mitigation.\n- If `fd` is valid, it retrieves the file pointer from `io_fixed_file_slot(&ctx->file_table, fd)->file_ptr`.\n- The file pointer is then masked with `FFS_MASK` to extract the `struct file *` pointer.\n- It checks if the resulting `cd->file` is non-null before proceeding.\n\nThe function also checks for invalid flags (`IORING_ASYNC_CANCEL_FD` and `IORING_ASYNC_CANCEL_FD_FIXED`) and returns `-EBADF` if `fd` is out of bounds or if the file pointer is null.\n\nStep 2: Identify potential security issues  \n- Buffer overflow? No \u2014 no buffer is being written to or read from with unbounded input.\n- SQL injection? Not applicable \u2014 this is kernel code, not user-facing or database-related.\n- Command injection? No \u2014 no shell commands or system calls are executed.\n- Path traversal? Not applicable \u2014 no file path handling.\n- Input validation? The function validates `fd` against `ctx->nr_user_files` and uses `array_index_nospec`, which is designed to prevent out-of-bounds access. The use of `unlikely()` and bounds checking suggests defensive programming.\n- Memory safety? The use of `array_index_nospec` and bounds checks on `fd` prevents out-of-bounds access. The file pointer is masked with `FFS_MASK`, which is a known safe operation in kernel contexts to extract valid file pointers.\n- Use-after-free or null dereference? The code checks if `cd->file` is null before using it, so a null dereference is avoided.\n- Race conditions? The function is called under a lock context (as noted in the comment: \"fixed must be grabbed every time since we drop the uring_lock\"), so race conditions are mitigated by synchronization.\n\nThe code is written in a secure kernel context with proper bounds checking and safe indexing.\n\nStep 3: Make your final decision  \nThere are no observable security vulnerabilities such as buffer overflows, injection, or improper access control. The input validation and memory safety checks are appropriate for kernel code.\n\nFinal Answer: NO  \nThe code does not contain any security vulnerabilities. It properly validates file descriptor bounds, uses safe indexing, and avoids null dereferences. All operations are within the expected kernel memory safety model."}
